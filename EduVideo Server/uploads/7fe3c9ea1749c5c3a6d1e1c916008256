from pyspark.sql import SQLContext
import datetime
import dateutil.relativedelta
from pyspark import SparkContext
import sys
import numpy as np
import os
import shutil

dpbands = [5,10,15,20,25,30,35,40,45,50,55,60,65,70]
aspbands = [500,1000,1500,2000,2500,3000,3500,4000]
agebands = [18,22,26,30,34,38,42,46,50]
month = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC']
weekdays = ['Mon','Tue','Wed','Thr','Fri','Sat','Sun']
weeks = ['First','Second','Third','Fourth']
quantile = []
timeList  = [-1,7,15,23,31,39,46,53,61,69,76,84,92,100,107,137,168,199,290,380,2000]

#def getPos(l, num):
	

timeField = ['Jan_2016_W2','Jan_2016_W1','Dec_2015_W4','Dec_2015_W3','Dec_2015_W2','Dec_2015_W1','Nov_2015_W4','Nov_2015_W3','Nov_2015_W2',
'Nov_2015_W1','Oct_2015_W4','Oct_2015_W3','Oct_2015_W2','Oct_2015_W1','Sep_2015_M','Aug_2015_M','Jul_2015_M','Apr_Jun_2015_Q',
'Jan_Mar_2015_Q','Before_Dec_2014']

def calPercentile(t):
	global quantile
	l = np.array(t)
	for i in range(1,101):
		quantile.append(np.percentile(l,i))

def getPercentile(v):
    global quantile
    if v <= quantile[0]:
        return 0
    for i in range(1,len(quantile)):
        if v <= quantile[i] and v > quantile[i-1]:
            return (i * 100 ) / len(quantile)
    return 100

def segment(y,bands):
	res = {}
	for x in y:
		if x <= bands[0]:
			t = "LT " + str(bands[0])
			if t in res:
				res[t] += 1
			else:
				res[t] = 1
			continue
		for i in range(1,len(bands)):
			if x <= bands[i]:
				t = str(bands[i-1]) + "-" + str(bands[i])
				if t in res:
					res[t] += 1
				else:
					res[t] = 1
				break
		if x > bands[len(bands)-1]:
			t = "GT " + str(bands[len(bands) - 1])
			if t in res:
				res[t] += 1
			else:
				res[t] = 1
       			continue
        res_list =[]
	for key in res:
		temp = {}
		temp['type'] = key
		temp['value'] = res[key]
		res_list.append(temp)
	return res_list
    

def typeConversion(x):
	global field
	y = []
	for each in x:
		y.append(each.replace('"',''))
	dict1 ={}
	for i in range(3,17):
		dict1[field[i]] = y[i]
		if i in [4,5,6,7]:
			dict1[field[i]] = float(dict1[field[i]])
		elif i in [1,3,8,16]:
			try:
				dict1[field[i]] = int(dict1[field[i]])
			except:
				if i == 3:
					dict1[field[i]] = 1700
				elif i == 8:
					dict1[field[i]] = 1
				else:
					dict1[field[i]] = 0
		else:
			dict1[field[i]] = dict1[field[i]].encode('utf-8')
	dict1['article_type'] = dict1['gender'] + "-" + dict1['article_type']
	dict1['master_category'] = dict1['gender'] + "-" + dict1['master_category']
	dict1['mrp_value'] = dict1['mrp'] * dict1['quantity']
	dict1['date'] = y[1].encode('utf-8')
	diff = datetime.datetime.strptime('20160115', '%Y%m%d').date() - datetime.datetime.strptime(dict1['date'], '%Y%m%d').date()
	for i in range(len(timeList) - 1):
		if timeList[i] <= diff.days and diff.days < timeList[i + 1]:
			break
			#dict1['bucket'].append(timeField[i])
	tup = ((str(y[0]),str(y[1]),str(y[2]),str(timeField[i])),dict1)
	return tup


def seqOper(x,y):
	global field
	dict1 ={}
	for i in range(3,17):
		dict1[field[i]] = y[field[i]]
	dict1['asp_list'] = list()
	dict1['asp_list'].append(y['mrp'])
	dict1['mrp_value'] = y['mrp_value']
	dict1['styles'] = list()
	dict1['styles'].append(y['style_id'])
	dict1['items'] = y['quantity']
	dict1['genders'] = list()
	dict1['genders'].append(y['gender'])
	dict1['article_types'] = list()
	dict1['article_types'].append(y['article_type'])
	dict1['master_categories'] = list()
 	dict1['master_categories'].append(y['master_category'])
	dict1['brands'] = list()
	dict1['brands'].append(y['brand'])
	dict1['date'] = y['date']
	dict1['discount_list'] = list()
	dict1['discount_list'].append(y['discount'])
	if y['returned'] == 1:
		dict1['returned_value'] = y['revenue']
		dict1['returned_count'] = 1
		dict1['revenue'] = 0
	else:
		dict1['returned_value'] = 0
		dict1['returned_count'] = 0
	return dict1

def combineOper(x,y):
	dict1 = {}
	dict1['revenue'] = x['revenue'] + y['revenue']
	dict1['quantity'] = x['quantity'] + y['quantity']
	dict1['items'] = x['quantity'] + y['quantity']
	dict1['rgm'] = x['rgm'] + y['rgm']
	dict1['discount'] = x['discount'] + y['discount']
	dict1['mrp_value'] = x['mrp_value'] + y['mrp_value']
	dict1['styles'] = x['styles'] + y['styles']
	dict1['city'] = x['city'] 
	dict1['state'] = x['state'] 
	dict1['genders'] = x['genders'] + y['genders']
	dict1['article_types'] = x['article_types'] + y['article_types']
	dict1['master_categories'] = x['master_categories'] + y['master_categories']
	dict1['brands'] = x['brands'] + y['brands']
	dict1['date'] = x['date']  #check this line
	dict1['time'] = x['time']
	dict1['asp_list'] = x['asp_list'] + y['asp_list'] 
	dict1['returned_value'] = x['returned_value'] + y['returned_value']
	dict1['returned_count'] = x['returned_count'] + y['returned_count'] 
	dict1['discount_list'] = x['discount_list']  + y['discount_list']
	return dict1

def date_id(x):
	dict1 = x[1]
	dict1['date_id'] = str(x[0][1]) + '-' + x[0][2]
	tup = ((x[0][0], x[0][3]),dict1)
	return tup

def userSeq(x,y):
	dict1 = y
	dict1['orders'] = 1
	dict1['items'] = y['items']
	dict1['revenue'] = y['revenue']
	dict1['rgm'] = y['rgm']
	dict1['discount_total'] = y['discount']
	dict1['mrp_total'] = y['mrp_value']
	dict1['date_list'] =[]
	# dict1['bucket'] = []
	dict1['date_list'].append(y['date'])
	dict1['revenue_list'] = {y['date_id']:y['revenue']}
	dict1['rgm_list'] = {y['date_id']:y['rgm']}
	dict1['item_list'] = {y['date_id']:y['items']}
	dict1['discount_list'] = y['discount_list']
	dict1['mrp_list'] = {y['date_id']:y['mrp_value']}
	dict1['order_asp_list'] = y['asp_list']
	dict1['style_list'] = y['styles']
	dict1['article_list'] = {y['date_id']:y['article_types']}
	dict1['gender_list'] = y['genders']
	dict1['master_category_list'] = y['master_categories']
	dict1['article_type_list'] = y['article_types']
	dict1['purchased_brands'] = y['brands']
	dict1['city_list'] = y['city']
	dict1['state_list'] = y['state']
	dict1['time_list'] = []
	dict1['time_list'].append(y['time'])
	return dict1

def userCombine(x,y):
	dict1 = {}
	dict1['revenue'] = x['revenue'] + y['revenue']
	dict1['orders'] = x['orders'] + y['orders']
	dict1['items'] = x['items'] + y['items']
	dict1['rgm'] = x['rgm'] + y['rgm']
	# dict1['bucket'] = x['bucket'] + y['bucket']
	dict1['date_list'] = x['date_list'] + y['date_list']
	dict1['discount_list'] = x['discount_list'] + y['discount_list']
	dict1['order_asp_list'] = x['asp_list'] + y['asp_list']
	dict1['style_list'] = x['style_list'] + y['style_list']
	dict1['asp_list'] = x['asp_list'] + y['asp_list']
	dict1['gender_list'] = x['gender_list']+y['gender_list']
	dict1['master_category_list'] = x['master_category_list']+y['master_category_list']
	dict1['article_type_list'] = x['article_type_list']+y['article_type_list']
	dict1['purchased_brands'] = x['purchased_brands']+y['purchased_brands']
	dict1['city_list'] = x['city_list']
	dict1['state_list'] = x['state_list']
	dict1['time_list'] = x['time_list'] + y['time_list']
	dict1['returned_value'] = x['returned_value'] + y['returned_value']
	dict1['returned_count'] = x['returned_count'] + y['returned_count'] 
	return dict1

def bucket(x):
	d = {}
	d[x[0][1]] = x[1]
	#dict1 = x[1]
	#dict1['bucket'] = x[0][1]
	tup = ((x[0][0]),d)
	return tup

def merge_two_dicts(x, y):
    '''Given two dicts, merge them into a new dict as a shallow copy.'''
    z = x.copy()
    z.update(y)
    return z


def createList(x):
	dist = set()
	for k in x:
		dist.add(x[k])
	return list(dist)

def dayOfWeek(dates):
	days = {}
	for each in dates:
		each = str(each)
		da = datetime.date(int(each[:4]),int(each[4:6]),int(each[6:]))
		n = da.weekday() - 1
		if weekdays[n] in days:
			days[weekdays[n]] += 1
		else:
			days[weekdays[n]] = 1
	return days

def weekOfMonth(dates):
	week ={}
	for each in dates:
		da = int(each[6:]) / 8
		if weeks[da] in week:
			week[weeks[da]] += 1
		else:
			week[weeks[da]] = 1
	return week

def timeOfDay(times):
	t = {}
	for each in times:
		each = str(each)
		if len(each)< 4:
			continue
		elif len(each) == 3:
			d = int(each[:1]) + int(each[1:])/60.0
		else:
			d = int(each[:2]) + int(each[2:])/60.0
		if d >= 8 and d < 12:
			if '8-12' in t:
				t['8-12'] += 1
			else:
				t['8-12'] = 1
		elif d>= 12 and d<16:
			if '12-16' in t:
				t['12-16'] += 1
			else:
				t['12-16'] = 1
		elif d>= 16 and d < 20:
			if '16-20' in t:
				t['16-20'] += 1
			else:
				t['16-20'] = 1
		elif d>=20 and d<23:
			if '20-23' in t:
				t['20-23'] += 1
			else:
				t['20-23'] = 1
		else:
			if '23-8' in t:
				t['23-8'] += 1
			else:
				t['23-8'] = 1
	return t



def computeAllFields(y):
	x = y[1]
	d = {}
	#d['CustomerID'] = y[0][0]
	#d['Location'] = list()
	d['City'] = x['city_list']
	d['State'] = x['state_list']
	#d['Ordered_Genders'] = x['gender_list']
	d['No_of_Orders'] = x['orders']
	#d['Purchased_Brands'] = x['purchased_brands']
	d['Item_ASP'] = x['asp_list']  #avg
	d['Order_ASP'] = x['order_asp_list'] #avg
	d['Date_List'] = x['date_list'] #no need
	# d['Bucket_List'] = x['bucket']
	d['Time_List'] = x['time_list'] #no need
	d['StyleIDs'] = x['style_list'] #no need
	d['No_of_Items'] = x['items']
	d['RGM'] = x['rgm']
	#d['Article_Types'] = x['article_type_list'].split(',')
	#d['Master_Categories'] = x['master_category_list'].split(',')
	d['Discount_Value'] = x['discount_list'] 
	d['Discount_Value'] = np.array([float(r) for r in d['Discount_Value']])  #avg
	t = np.array(d['Order_ASP'])  
	d['Discount_Value'] = d['Discount_Value'] / d['Order_ASP']  #vavg
	d['Discount_Value'] = [ w*100 for w in d['Discount_Value']]  #avg
	d['Order_ASP_Bands'] = segment(d['Order_ASP'],aspbands)
	d['Item_ASP_Bands'] = segment(d['Item_ASP'],aspbands)
	d['Discount_Value_Bands'] = segment(d['Discount_Value'],dpbands)
	d['Day_of_Week'] = dayOfWeek(d['Date_List'])
	d['Week_of_month'] = weekOfMonth(d['Date_List'])
	d['Time_of_Day'] = timeOfDay(d['Time_List'])
	d['Returned_Value'] = x['returned_value']
	d['Returned_item_count'] = x['returned_count']
	d['Total_Revenue'] = x['revenue'] 
	d['Purchase_Event'] = list() 
	#print 'brand',x['purchased_brands']
	#print 'gender',x['gender_list']
	#print 'article',x['article_type_list']
	#print 'category',x['master_category_list']
	for i in range(len(x['purchased_brands'])):
		temp_dict ={}
		temp_dict['brand'] = x['purchased_brands'][i]
		temp_dict['gender'] = x['gender_list'][i]
		temp_dict['article'] = x['article_type_list'][i]
		temp_dict['category'] = x['master_category_list'][i]
		d['Purchase_Event'].append(temp_dict)
	bucket ={}
	bucket[y[0][1]] = d
	return (y[0][0],bucket)

def currentUsers():
	global db
	r = db.userList.find()
	u =[]
	for doc in r:
		u += [str(x) for x in doc['users']]
		#= [str(x) for x in r['users']]
	return u

def updateDict(x,y):
	z = x;
	for each in y:
		if each in z:
			z[each] += y[each]
		else:
			z[each] = y[each]
	return z  

def readSummaryFields(user_id,x):
	global month_element
	user_doc = {}
	user_doc['CustomerID'] = user_id
	del x['CustomerID']
	user_doc[month_element] = x
	return user_doc

def createNew(x):
	global month_element
	x['Month'] = month_element
	return x

def writeUsers(u):
	n = 10000
	for i in range(0,len(u),n):
		db.userList.insert({'users':u[i:i+n]})


field =['user','date','order_id','time','revenue','rgm','discount','mrp','quantity','city','state','style_id','brand','gender','article_type','master_category','returned']
month_element = 'Nov_2015'

if __name__ == '__main__':
	
	month_element = 'Sep_2015'
	sc = SparkContext()
	sqlContext = SQLContext(sc)
	field =['user','date','order_id','time','revenue','rgm','discount','mrp','quantity','city','state','style_id','brand','gender','article_type','master_category','returned']
	plaintext_rdd = sc.textFile('orderslist.csv0009_part_00')
	rdd = plaintext_rdd.map(lambda line: line.split(","))
	orders = rdd.map(typeConversion)
	print '1'
	order_groups = orders.aggregateByKey('',seqOper,combineOper)
	print '2'
	order_groups1 = order_groups.map(date_id)
	user_orders = order_groups1.aggregateByKey('',userSeq,userCombine)

	user_orders1 = user_orders.map(computeAllFields)

	bucket = user_orders1.reduceByKey(merge_two_dicts)

	bucket.saveAsTextFile('orderlist_aggreate')

	print '3'
	dir = 'orderlist_aggreate'
	if os.path.exists(dir):
		shutil.rmtree(dir)
	#os.makedirs(dir)
	#.saveAsTextFile('orderlist_aggreate')
	with open('outputjson.json','w') as f:
		f.write(str(user_orders1.collect()))

	# print 'completed the aggregation'
	# print ' writing to mongo'
	#code to update mongo
	#client = pymongo.MongoClient('bi-cip-0.atlas-mongo-auto-m.2311.mongodbdns.com',27017)
	# db = client.cip

	#user_list = currentUsers()
	#new_users = []
	# i = 0
	# tomongo =[]
	# for x in user_orders1:
	# 	i += 1
	# 	s = createNew(x)
	# 	t = InsertOne(s)
	# 	tomongo.append(t)
	# 	if(i == 1000):
	# 		db.transactional.bulk_write(tomongo)
	# 		tomongo =[]
	# 		i = 0 
	# db.transactional.bulk_write(tomongo)	
	# print 'Writing to mongo succesful!!'
